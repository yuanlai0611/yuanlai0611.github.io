<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Material Design的研究(一)]]></title>
    <url>%2F2018%2F05%2F01%2FMaterial-Design%E7%9A%84%E7%A0%94%E7%A9%B6-%E4%B8%80%2F</url>
    <content type="text"><![CDATA[由沉浸式状态栏引出援引一句郭霖大神的话来破除大家对沉浸式的误解。 其实说到沉浸式状态栏这个名字我也是感到很无奈，真不知道这种叫法是谁先发起的。因为Android官方从来没有给出过沉浸式状态栏这样的命名，只有沉浸式模式（Immersive Mode）这种说法。而有些人在没有完全了解清楚沉浸模式到底是什么东西的情况下，就张冠李戴地认为一些系统提供的状态栏操作就是沉浸式的，并且还起了一个沉浸式状态栏的名字。 所以说真正的沉浸式是什么，还是援引郭霖大神的话： 那么对应到Android操作系统上面，怎样才算是沉浸式体验呢？这个可能在大多数情况下都是用不到的，不过在玩游戏或者看电影的时候就非常重要了。因为游戏或者影视类的应用都希望能让用户完全沉浸在其中，享受它们提供的娱乐内容，但如果这个时候在屏幕的上方还显示一个系统状态栏的话，可能就会让用户分分钟产生跳戏的感觉。 但是我们就是想要我们以前以为的沉浸式的效果，就像Tim和网易云音乐那种效果我们到底要怎么达成呢？我们有两种思路，一个是指定状态栏的颜色，也就是纯色的，还有一种就是通过全屏模式 这是Tim的图片 这是网易云音乐的状态栏介绍一下几个属性： fitsSystemWindows：我们的理解是：在Android版本大于5.0的情况下，对于CoordinatorLayout、AppBarLayout、CollapsingToolbarLayout一起使用的时候，如果对其中的一个子控件设置fitsSystemWindows时，需要对它们的父控件都设置该属性；但是对于其它情况，这个属性的含义是为了不让我们的控件占据系统窗口的空间，比如说状态栏和导航栏（这一属性需要设置状态栏或者导航栏透明或者半透明的时候才会有效）。 指定状态栏的颜色来实现沉浸式（这种说法不准确，但是还是暂时这么说）在style.xml里面设置对应的Activity的theme，通过设置android:statusBarColor这一属性来直接设置状态栏的颜色，这种方案适用于==纯色==的toolBar或者ActionBar，具体代码如下： 123&lt;style name="MainActivityTheme" parent="AppTheme"&gt; &lt;item name="android:statusBarColor"&gt;@color/colorPrimary&lt;/item&gt;&lt;/style&gt; 在AndroidManifest.xml中设置刚才定义的style，具体的代码如下： 12345678&lt;activity android:name=".MainActivity" android:theme="@style/MainActivityTheme"&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.MAIN" /&gt; &lt;category android:name="android.intent.category.LAUNCHER" /&gt; &lt;/intent-filter&gt;&lt;/activity&gt; 通过设置全屏和状态栏透明来实现沉浸式我们首先在需要设置全屏，保持状态栏悬浮，具体的代码如下： 123View view = getWindow().getDecorView(); int options = View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN|View.SYSTEM_UI_FLAG_LAYOUT_STABLE;view.setSystemUiVisibility(options); 接着我们设置状态栏，具体的代码如下： 1getWindow().setStatusBarColor(Color.TRANSPARENT); 通过设置全屏和设置状态栏为TRANSLUCENT来实现沉浸式首先也要设置全屏，和之前的一样，接着要设置状态栏透明（在5.0以上为半透明） 1getWindow().addFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS); Toolbar——Actionbar的替代者一个Toolbar的基本效果如下图所示： 我们通常会设置Toolbar的navigationicon、subtitle、title、menu和logo，设置这些属相的代码我贴在下面了： 12345678910111213&lt;android.support.v7.widget.Toolbar android:id="@+id/toolbar" android:paddingTop="24dp" android:layout_width="match_parent" android:minHeight="?attr/actionBarSize" android:layout_height="wrap_content" android:background="@color/colorPrimary" android:theme="@style/Base.ThemeOverlay.AppCompat.Dark.ActionBar" app:navigationIcon="@drawable/ic_menu" app:logo="@drawable/ic_head" app:popupTheme="@style/Base.ThemeOverlay.AppCompat" app:title="@string/app_name" app:subtitle="yuanlai" /&gt; 因为我们指定的style为Light，所以文字会变成深色，这会很难看的，这里我们需要把Actionbar的theme设置为深色，这样文字就会变成浅色，但是这样弹出的菜单项会变成深色，所以我们又需要设置弹出菜单的theme。xmlns:app是因为Material Design库在Android 5.0系统中才出现，在之前的系统中并不存在，所以为了兼容之前的系统，才会有app:这种写法。 同时我们发现ToolBar和statusbar的颜色保持一致，这里我们用到之前设置statusbar的知识，设置为全屏然后接着设置statusbar为透明色，这里特殊之处在于我们为Toolbar设置的高度为wrap_content并设置了一个最小的高度，这样就可以保证statusbar处的颜色和Toolbar的颜色一致。 接下来我们来具体分析这些属性该怎么用： title、subtitle、logo、navigationicon的设置这几个属性直接用app:加上对应的属性名即可。 menu 和 navigationicon的点击事件设置：其中menu的填充一定要在代码中执行，具体定义的步骤如下： 先在menu文件下面新建一个menu文件用来承载具体的menu的内容 123456789101112131415161718192021&lt;menu xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto"&gt; &lt;item android:id="@+id/backup" android:icon="@drawable/ic_backup_white" android:title="Backup" app:showAsAction="always"/&gt; &lt;item android:id="@+id/delete" android:icon="@drawable/ic_delete_white" android:title="Delete" app:showAsAction="ifRoom"/&gt; &lt;item android:id="@+id/settings" android:icon="@drawable/ic_settings_white" android:title="Setting" app:showAsAction="never"/&gt;&lt;/menu&gt; 在代码里面填充刚刚定义的menu文件 12345@Override public boolean onCreateOptionsMenu(Menu menu) &#123; getMenuInflater().inflate(R.menu.toolbar,menu); return true; &#125; 设置menu的点击事件 1234567891011121314151617@Override public boolean onOptionsItemSelected(MenuItem item) &#123; switch (item.getItemId()) &#123; case R.id.backup: Toast.makeText(this, "You clicked backup", Toast.LENGTH_SHORT).show(); break; case R.id.delete: Toast.makeText(this, "You clicked delete", Toast.LENGTH_SHORT).show(); break; case R.id.settings: Toast.makeText(this, "you clicked settings", Toast.LENGTH_SHORT).show(); break; default: break; &#125; return true; &#125; 而我们之前设置的navigationicon的点击事件设置则更加简单，其具体代码如下： 123456toolbar.setNavigationOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; &#125;&#125;); 附：Toolbar可是一个viewgroup在实际开发中我们会遇见一个两难的情况，我们希望Toolbar的title到中间去，但是Toolbar似乎不给我们留什么修改它的接口，但是Material Design的许多效果要搭配Toolbar使用才行，比如说CollapsingToolbarLayout。所以说我们得换一个思路，即把Toolbar作为一个viewgroup，具体的代码如下： 1234567891011121314151617&lt;android.support.v7.widget.Toolbar android:id="@+id/toolbar" android:paddingTop="24dp" android:layout_width="match_parent" android:minHeight="?attr/actionBarSize" android:layout_height="wrap_content" android:background="@color/colorPrimary" android:theme="@style/Base.ThemeOverlay.AppCompat.Dark.ActionBar"&gt; &lt;TextView android:layout_gravity="center" android:text="@string/app_name" android:layout_width="wrap_content" android:layout_height="wrap_content" style="@style/TextAppearance.AppCompat.Widget.ActionBar.Title"/&gt;&lt;/android.support.v7.widget.Toolbar&gt; 这一段代码关键是设置了layot_gravity和style属性，其中style把自定义的Textview显示的和Actionbar.Title保持一致，同时还需要在代码里面控制Actionbar的title不显示，具体的代码如下： 1getSupportActionBar().setDisplayShowTitleEnabled(false); 附：利用actionLayout来模仿网易云我在网上看到大神亦枫的博客，看到他利用Toolbar做出了网易云音乐搜索栏的效果，感觉很牛逼。在通常情况下，Toolbar的Menu item只有一个icon，但是有时候有些特殊情况，需要我们自定义Menu item,最后完成的效果如下图所示：我们需要额外定义一个layout文件，然后通过actionLayout属性引入到标签中。layout具体代码如下： 12345678910&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="wrap_content"&gt;&lt;EditText xmlns:android="http://schemas.android.com/apk/res/android" android:hint="搜索音乐、歌手、歌词、用户" android:layout_width="match_parent" android:layout_height="wrap_content"/&gt;&lt;/RelativeLayout&gt; 这里需要注意两点： 那个layout的跟布局必须是以RelativeLayout作为根布局，否则，视图无法填满Toolbar或者是Actionbar。 actionLayout这一属性必须是以app为命名空间。 将menu item移至中间如果我们想把menu移到中间来，而不是把它放到右边去，这个时候我们就需要想到用ActionMenuView，其作为Toolbar的一个子控件，把menu item都放到自己里面，我们先来看看它的布局： 123456789101112131415&lt;android.support.v7.widget.Toolbar android:id="@+id/toolbar" android:paddingTop="24dp" android:layout_width="match_parent" android:minHeight="?attr/actionBarSize" android:layout_height="wrap_content" android:background="@color/colorRed" android:theme="@style/Base.ThemeOverlay.AppCompat.Dark.ActionBar" app:popupTheme="@style/Base.ThemeOverlay.AppCompat" &gt; &lt;android.support.v7.widget.ActionMenuView android:layout_gravity="center" android:id="@+id/amv_search" android:layout_width="wrap_content" android:layout_height="wrap_content"/&gt; &lt;/android.support.v7.widget.Toolbar&gt; 接着在代码里把menu资源文件加载到通过findViewById()找到的ActionMenuView里面去，具体的代码如下所示： 12345@Override public boolean onCreateOptionsMenu(Menu menu) &#123; getMenuInflater().inflate(R.menu.toolbar, amvSearch.getMenu()); return true;&#125; 接着直接对ActionMenuView设置点击事件，具体代码如下: 1234567891011amvSearch.setOnMenuItemClickListener(new ActionMenuView.OnMenuItemClickListener() &#123; @Override public boolean onMenuItemClick(MenuItem item) &#123; switch (item.getItemId())&#123; &#125; return false; &#125;&#125;); 具体的效果图如下：]]></content>
      <categories>
        <category>Material Design</category>
      </categories>
      <tags>
        <tag>Material Design</tag>
        <tag>沉浸式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Retrofit2 学习笔记]]></title>
    <url>%2F2018%2F04%2F28%2FRetrofit2-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[准备工作 Retrofit 2 是一款Android网络请求框架，其底层是基于OkHttp实现的，它与其它网络框架的不同之处在于，它更多使用运行时注解的功能提供此功能。、 我学习这个框架的目的是为学习Rxjava打下基础 一开始当然是引入retrofit的库，具体的可以看retrofit的官方网站，里面列举了所有用法的例子，为了帮助大家快速的上手，我把导入包的方式列举在下面，当然最新的还是要去它的官网看的。 GRADLEcompile &#39;com.squareup.retrofit2:retrofit:2.4.0&#39; 然而引入这个是不够的，大家还需要引入GSON转换的库，也在下面跟大家列举出来了。 com.squareup.retrofit2:converter-gson:2.3.0 当然不止这些转化的类型，还有其它很多库，我在这里就不一一列举了，大家想要的可以去它的官网看，至于有哪些类型大家可以参考下图： Retrofit的Get请求我们通过向淘宝的ip地址库发送Get请求来讲解如何使用Retrofit的Get请求，请求的顺序大致是： 定义返回值的实体类 定义一个网络接口 创建一个Retrofit对象 创建一个接口对象 实现接口 定义返回值的实体类我们通过分析返回值来构造一个实体类，拿淘宝的ip地址库的返回值举一个例子，其返回值具体如下： 123456789101112131415161718&#123; "code": 0, "data": &#123; "ip": "59.108.54.37", "country": "中国", "area": "", "region": "北京", "city": "北京", "county": "XX", "isp": "方正宽带", "country_id": "CN", "area_id": "", "region_id": "110000", "city_id": "110100", "county_id": "xx", "isp_id": "100063" &#125;&#125; 我们通过返回的值来构造一个Java Bean类，具体的代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143public class TaoBaoInfo &#123; private int code; private DataBean data; public int getCode() &#123; return code; &#125; public void setCode(int code) &#123; this.code = code; &#125; public DataBean getData() &#123; return data; &#125; public void setData(DataBean data) &#123; this.data = data; &#125; public class DataBean &#123; private String ip; private String country; private String area; private String region; private String city; private String county; private String isp; private String country_id; private String area_id; private String region_id; private String city_id; private String county_id; private String isp_id; public String getIp() &#123; return ip; &#125; public void setIp(String ip) &#123; this.ip = ip; &#125; public String getCountry() &#123; return country; &#125; public void setCountry(String country) &#123; this.country = country; &#125; public String getArea() &#123; return area; &#125; public void setArea(String area) &#123; this.area = area; &#125; public String getRegion() &#123; return region; &#125; public void setRegion(String region) &#123; this.region = region; &#125; public String getCity() &#123; return city; &#125; public void setCity(String city) &#123; this.city = city; &#125; public String getCounty() &#123; return county; &#125; public void setCounty(String county) &#123; this.county = county; &#125; public String getIsp() &#123; return isp; &#125; public void setIsp(String isp) &#123; this.isp = isp; &#125; public String getCountry_id() &#123; return country_id; &#125; public void setCountry_id(String country_id) &#123; this.country_id = country_id; &#125; public String getArea_id() &#123; return area_id; &#125; public void setArea_id(String area_id) &#123; this.area_id = area_id; &#125; public String getRegion_id() &#123; return region_id; &#125; public void setRegion_id(String region_id) &#123; this.region_id = region_id; &#125; public String getCity_id() &#123; return city_id; &#125; public void setCity_id(String city_id) &#123; this.city_id = city_id; &#125; public String getCounty_id() &#123; return county_id; &#125; public void setCounty_id(String county_id) &#123; this.county_id = county_id; &#125; public String getIsp_id() &#123; return isp_id; &#125; public void setIsp_id(String isp_id) &#123; this.isp_id = isp_id; &#125; &#125;&#125; 定义一个网络接口接着我们需要定义一个网络接口，具体的代码如下： 123456public interface TaoBaoService &#123; @GET("getIpInfo.php") Call&lt;TaoBaoInfo&gt; getIpMsg(@Query("ip")String ip);&#125; 这里有几个特殊的地方，在@Get后面的括号里面接着的是该请求的相对地址，其中Call的一堆尖括号里面对应的是返回的数据类型，也就是我们第一步定义的实体类@Query(&quot;ip&quot;)对应的是请求的数据对应的key值，具体的我们可以分析一个请求的url，具体url值如下：http://ip.taobao.com/service/getIpInfo.php?ip=59.108.54.37这个url中？号后面跟着的是请求的数据，假如有多个数据的话要加上&amp;号，我们来举个例子，还是这个url，假如我们要加几个请求的数据，比如说时间，我们就可以这样写url：http://ip.taobao.com/service/getIpInfo.php?ip=59.108.54.37&amp;time=12:00那我们请求对于这种多个请求的情况就可以通过传入map，那么具体的接口写法如下： 12345public interface TaoBaoService &#123;@GET("getIpInfo.php") Call&lt;TaoBaoInfo&gt; getIpMsg(@QueryMap Map&lt;String,String&gt; options);&#125; 创建一个Retrofit对象12345Retrofit retrofit = new Retrofit.Builder() .baseUrl("http://ip.taobao.com/service/") .addConverterFactory(GsonConverterFactory.create()) .addConverterFactory(ScalarsConverterFactory.create()) .build(); 其重有两个要点： 设置baseUrl,也就是请求的基地址 设置转换的格式，我们这里把返回的结果转换成Gson或者String，当然还有其它的选择，具体可以参照我们一开始提的准换格式的问题创建一个接口对象这个主要是创建一个接口对象，没有什么好说的TaobaoService api = retrofit.create(TaoBaoService.class); 实现接口实现接口的具体代码如下所示： 123456789101112api.getIpMsg("59.108.54.37").enqueue(new Callback&lt;TaoBaoInfo&gt;() &#123; @Override public void onResponse(Call&lt;TaoBaoInfo&gt; call, Response&lt;TaoBaoInfo&gt; response) &#123; Toast.makeText(MainActivity.this, response.body().getData().getCity(), Toast.LENGTH_SHORT).show(); &#125; @Override public void onFailure(Call&lt;TaoBaoInfo&gt; call, Throwable t) &#123; Toast.makeText(MainActivity.this, "获取失败", Toast.LENGTH_SHORT).show(); &#125; &#125;); 这里不用管线程切换的问题，回调就发生在主线程中。对于第二种定义接口的方式，我们的实现方式如下所示： 1234567891011121314Map map = new HashMap&lt;String,String&gt;;map.put("ip","59.108.54.37");api.getIpMsg(map).enqueue(new Callback&lt;TaoBaoInfo&gt;() &#123; @Override public void onResponse(Call&lt;TaoBaoInfo&gt; call, Response&lt;TaoBaoInfo&gt; response) &#123; Toast.makeText(MainActivity.this, response.body().getData().getCity(), Toast.LENGTH_SHORT).show(); &#125; @Override public void onFailure(Call&lt;TaoBaoInfo&gt; call, Throwable t) &#123; Toast.makeText(MainActivity.this, "获取失败", Toast.LENGTH_SHORT).show(); &#125; &#125;); 用Path来代替路径也许看这个标题会很疑惑，我们来用一个url来举一个具体的例子：http://ip.taobao.com/service/getIpInfo.php?ip=59.108.54.37我们可以把基地址写成http://ip.taobao.com/，后面接着的service可以被指定为一种路径，这种方式方便减少基地址的数量，也可以用来传输值，比如说之前的http://ip.taobao.com/service/getIpInfo.php?ip=59.108.54.37&amp;time=12:00可以被写成http://ip.taobao.com/service/getIpInfo.php/59.108.54.37/12:00,也就是说传输的值直接被写进路径里面去了，接着我们来写如何具体实现这一方法,首先我们得重新写一个接口，具体的代码如下： 1234567public interface TaoBaoService &#123;@GET("&#123;path&#125;/getIpInfo.php") Call&lt;TaoBaoInfo&gt; getIpMsg(@Path("path") String path, @Query("ip") String ip);&#125;&#125; @Path后面跟着的括号里面的值必须和@Get括号里面的{path}占位符一样。接着我们写实现接口的代码，具体代码如下： 123456789101112api.getIpMsg("service"，"59.108.54.37").enqueue(new Callback&lt;TaoBaoInfo&gt;() &#123; @Override public void onResponse(Call&lt;TaoBaoInfo&gt; call, Response&lt;TaoBaoInfo&gt; response) &#123; Toast.makeText(MainActivity.this, response.body().getData().getCity(), Toast.LENGTH_SHORT).show(); &#125; @Override public void onFailure(Call&lt;TaoBaoInfo&gt; call, Throwable t) &#123; Toast.makeText(MainActivity.this, "获取失败", Toast.LENGTH_SHORT).show(); &#125; &#125;); Retrofit的Post请求Retrofit的Post请求和Get请求有很多相似的地方，Post的步骤也可以总结如下： 定义返回值的实体类 定义一个网络接口 创建一个Retrofit对象 创建一个接口对象 实现接口 其重步骤1和步骤3,4都是一样的，我们在这里只用讲解下步骤2,5，其具体的代码如下： 定义一个网络接口1234567public interface UserService &#123; @FormUrlEncoded @POST("api/user/dogetInfo") Call&lt;UserInfo&gt; getUserInfo(@Field("username") String username);&#125; 其中要注意两个地方其一是FormUrlEncoded，意思是Form表单提交，另一个@POST(&quot;api/user/dogetInfo&quot;)是指定请求的类型，这里的是一个Post请求，UserInfo处指的是返回的类型，也就是我们刚才根据返回的json数据构造的类，@Field(&quot;username&quot;)这里的括号里面的值是提交表单对应的key值。写完相应的接口我们在代码里面使用它，具体的代码如下先初始化接口： 实现接口12345678910111213api.getUserInfo("yuanlai").enqueue(new Callback&lt;UserInfo&gt;() &#123; @Override public void onResponse(Call&lt;UserInfo&gt; call, Response&lt;UserInfo&gt; response) &#123; Toast.makeText(MainActivity.this, response.body().getData().getSignature(), Toast.LENGTH_SHORT).show(); &#125; @Override public void onFailure(Call&lt;UserInfo&gt; call, Throwable t) &#123; &#125;&#125;); 这里要插一句，这里是异步请求网络，回调的callback是在UI线程里面执行的，所以我们可以直接地Toast。当然了，Retrofit除了表单提交数据外，还可以通过把提交的数据转换成Json格式发送到数据库。这里我只把一些代码简单地贴出来： 123456public interface UserService &#123; @POST("api/user/dogetInfo") Call&lt;UserInfo&gt; getUserInfoByJson(@Body User user);&#125; 初始化接口一些操作跟我们刚才的操作没有区别，接着我们要定义一个提交的json类，具体代码如下： 1234567891011121314151617public class User &#123; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public User(String username) &#123; this.username = username; &#125; String username; &#125; 具体操作的代码如下： 12345678910111213api.getUserInfoByJson(new User("yuanlai")).enqueue(new Callback&lt;UserInfo&gt;() &#123; @Override public void onResponse(Call&lt;UserInfo&gt; call, Response&lt;UserInfo&gt; response) &#123; Toast.makeText(MainActivity.this, response.body().getData().getSignature(), Toast.LENGTH_SHORT).show(); &#125; @Override public void onFailure(Call&lt;UserInfo&gt; call, Throwable t) &#123; &#125;&#125;);]]></content>
      <categories>
        <category>Retrofit And RxJava</category>
      </categories>
      <tags>
        <tag>网络请求</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jsoup 模拟登录]]></title>
    <url>%2F2018%2F04%2F23%2FJsoup-%E6%A8%A1%E6%8B%9F%E7%99%BB%E5%BD%95%2F</url>
    <content type="text"><![CDATA[在日常开发的时候，我们爬取数据，有些数据需要我们登陆之后才能够爬取。举一个例子，我们想要爬取学校图书馆里面的历史图书，我们就必须登陆以后再获取，这个时候我们可以选择模拟登陆——即我们可以用程序来模拟整个登陆的过程。 Jsoup模拟登陆的大概步骤(以待验证码的登陆为例) 首先对整个登陆过程进行网络分析，搞清楚需要用到哪些参数，以及请求的网址。 输入参数或者在网页中爬取相应的参数。 对请求网址发起网络请求，获取返回的数据，一般情况下是一个网页。 登录成功以后就可以通过获取之前网络请求的cookie来访问一些需要登录后才能浏览的网页 Jsoup模拟登陆的详细步骤 我们想要模拟登陆就必须了解整个登陆的完整过程，这里我推荐使用Google的Chrome浏览器来分析整个网络请求的过程。先用Chrome浏览器加载出登陆的页面，然后点反键选择检查，接着选择network。 按照提示刷新页面，mac使用command加R刷新后才能看到网络请求。我们先试着登录一遍，填好了所有的数据以后登录，我们可以看到我这个请求的所有请求参数可以在Headers里面的Form Data里面看到，下面的例子中我们一共看到了五个参数：1. number 2.passwd 3.captcha 4.select 5.returnUrl 同时在Headers里面的General可以看到登陆的请求网址。 这样我们需要的请求网址和所需的所有参数都知道了。 通过上面的一个步骤我们知道我们的所有参数里面有一个验证码需要我们获取，我的思路是先把他下载到本地再输入，那这个验证码如何获取呢？我们可以在所有的网络请求的列表里面看到验证码的请求，并且得到验证码的请求地址。 我们先向验证码的地址发送请求，获取到回应是二进制数组，再下载到本地。这里还要补充一句，我所有的网络请求和爬取数据用的都是Jsoup，需要在网络上面下载Jsoup的Jar包再添加到项目的lib里面，这里具体的做法我就不做阐述，具体的可以自己在网上搜索，这里可以参考Eclipse的三个方法，我是用的是外部添加Jar的方法。具体的代码如下： 12345678910111213141516171819202122Response response = Jsoup.connect("http://opac.lib.wust.edu.cn:8080/reader/captcha.php") .ignoreContentType(true) .execute(); byte[] data = response.bodyAsBytes(); cookie = response.cookies(); if (data != null) &#123; String filepath = "/Users/yuanyuanlai/Pictures"+"\\"+"yzm.gif"; File file = new File(filepath); if (file.exists()) &#123; file.delete(); &#125; try &#123; FileOutputStream fos = new FileOutputStream(file); fos.write(data, 0, data.length); fos.flush(); fos.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; 这里我们一定要注意上面的一个获取cookie的这个步骤，因为这个cookie联系整个步骤，要不然验证码怎么和后面的登录请求联系到一起 这一步里我们可以正式发送请求，具体的代码如下： 1234567891011121314151617181920System.out.println("请输入验证码:"); Scanner input = new Scanner(System.in); String yzm = input.next(); input.close(); Map&lt;String, String&gt; datas = new HashMap&lt;String,String&gt;(); datas.put("number", "201613137217"); datas.put("passwd", "310810"); datas.put("captcha", yzm); datas.put("select", "bar_no"); datas.put("returnUrl", ""); Connection connection2 = Jsoup.connect("http://opac.lib.wust.edu.cn:8080/reader/redr_verify.php"); connection2.header("User-Agent", "Mozilla/5.0 (Macintosh; Intel Mac OS X 10.13; rv:57.0) Gecko/20100101 Firefox/57.0"); res = connection2 .data(datas) .cookies(cookie) .method(Method.POST) .execute(); 将之前获取的验证码输入进去，以Map的形式储存请求的参数，简单的设置浏览器代理以后发送请求，这里最为重要的是在发送请求的时候也要带上cookie。 完成登录之后我们可以尝试着使用登录成功后的cookie爬取需要登录后的网页，比如我登录成功后想要爬取历史图书，比如下图： 我们在代码里面尝试着登录，爬取到历史图书，具体代码如下： 12345678document = Jsoup.connect("http://opac.lib.wust.edu.cn:8080/reader/book_hist.php") .cookies(cookie) .get(); Elements elements = document.select("table.table_line").select("tbody") .select("tr"); for(int i=1 ; i&lt;elements.size() ;i++) &#123; System.out.println(elements.get(i).select("td").get(2).text()); &#125; 爬取到的结果是： 说明登录成功，这里还得补充一句，Jsoup的具体教程得参考它的官方教程Jsoup教程 所有的代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384import java.io.File;import java.io.FileOutputStream;import java.io.IOException;import java.util.HashMap;import java.util.Map;import java.util.Scanner;import org.jsoup.Connection;import org.jsoup.Connection.Method;import org.jsoup.Connection.Response;import org.jsoup.Jsoup;import org.jsoup.nodes.Document;import org.jsoup.select.Elements;public class loginTest1 &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub Document document = null; Response res = null; Document doc = null; Map&lt;String, String&gt; cookie = new HashMap&lt;String,String&gt;(); try &#123; Response response = Jsoup.connect("http://opac.lib.wust.edu.cn:8080/reader/captcha.php") .ignoreContentType(true) .execute(); byte[] data = response.bodyAsBytes(); cookie = response.cookies(); if (data != null) &#123; String filepath = "/Users/yuanyuanlai/Pictures"+"\\"+"yzm.gif"; File file = new File(filepath); if (file.exists()) &#123; file.delete(); &#125; try &#123; FileOutputStream fos = new FileOutputStream(file); fos.write(data, 0, data.length); fos.flush(); fos.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; System.out.println("请输入验证码:"); Scanner input = new Scanner(System.in); String yzm = input.next(); input.close(); Map&lt;String, String&gt; datas = new HashMap&lt;String,String&gt;(); datas.put("number", "201613137217"); datas.put("passwd", "310810"); datas.put("captcha", yzm); datas.put("select", "bar_no"); datas.put("returnUrl", ""); Connection connection2 = Jsoup.connect("http://opac.lib.wust.edu.cn:8080/reader/redr_verify.php"); connection2.header("User-Agent", "Mozilla/5.0 (Macintosh; Intel Mac OS X 10.13; rv:57.0) Gecko/20100101 Firefox/57.0"); res = connection2 .data(datas) .cookies(cookie) .method(Method.POST) .execute(); document = Jsoup.connect("http://opac.lib.wust.edu.cn:8080/reader/book_hist.php") .cookies(cookie) .get(); Elements elements = document.select("table.table_line").select("tbody") .select("tr"); for(int i=1 ; i&lt;elements.size() ;i++) &#123; System.out.println(elements.get(i).select("td").get(2).text()); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125;]]></content>
      <categories>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>模拟登录</tag>
        <tag>Jsoup</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[稳稳的科学上网教程]]></title>
    <url>%2F2018%2F04%2F23%2F%E7%A8%B3%E7%A8%B3%E7%9A%84%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[服务器选择Centos 6x64 锐速更换内核： 1rpm -ivh http://soft.91yun.org/ISO/Linux/CentOS/kernel/kernel-firmware-2.6.32-504.3.3.el6.noarch.rpm 1rpm -ivh http://soft.91yun.org/ISO/Linux/CentOS/kernel/kernel-2.6.32-504.3.3.el6.x86_64.rpm --force reboot 1wget -N --no-check-certificate https://softs.fun/Bash/ssr.sh &amp;&amp; chmod +x ssr.sh &amp;&amp; bash ssr.sh 安装锐速 安装libsodium(chacha20) 安装ShadowSocksR 配置后的相关信息：相关链接：服务器网址，价格和可靠性都不错ping测试网站，用来检测ip地址是否被黑]]></content>
      <categories>
        <category>科学上网</category>
      </categories>
      <tags>
        <tag>实用工具</tag>
      </tags>
  </entry>
</search>
